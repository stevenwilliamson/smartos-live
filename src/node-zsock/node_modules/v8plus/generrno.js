#! /usr/bin/env node

/*
 * Copyright (c) 2014 Joyent, Inc.  All rights reserved.
 */

var util = require('util');
var fs = require('fs');
var mod_getopt = require('posix-getopt');

var prologue =
    '/*\n' +
    ' * STOP!\n' +
    ' *\n' +
    ' * Do not edit this file.  It is automatically generated by generrno.\n' +
    ' */\n\n';

var guard_prologue =
    '#ifndef\t_V8PLUS_ERRNO_H\n' +
    '#define\t_V8PLUS_ERRNO_H\n\n' +
    '#ifdef\t__cplusplus\n' +
    'extern "C" {\n' +
    '#endif\t/* __cplusplus */\n';

var decl_prologue =
    '#define\tV8PLUS_ERRNO_BASE\t0x10000\n\n' +
    'typedef enum _v8plus_errno {\n' +
    '\tV8PLUSERR_NOERROR = 0,\n' +
    '\tV8PLUSERR_%s = V8PLUS_ERRNO_BASE + 1,\n';

var decl_one =
    '\tV8PLUSERR_%s,\n';

var decl_epilogue =
    '} v8plus_errno_t;\n';

var guard_epilogue =
    '#ifdef\t__cplusplus\n' +
    '}\n' +
    '#endif\t/* __cplusplus */\n\n' +
    '#endif\t/* _V8PLUS_ERRNO_H */\n';

var include =
    '#include "v8plus_errno.h"\n\n';

var func_prologue =
    'const char *\n' +
    'v8plus_%s(v8plus_errno_t e)\n' +
    '{\n' +
    '\tswitch (e) {\n';

var generic_case =
    '\tcase V8PLUSERR_%s:\n' +
    '\t\treturn ("%s");\n';

var errname_case = 
    '\tcase V8PLUSERR_%s:\n' +
    '\t\treturn ("V8PLUSERR_%s");\n';

var func_epilogue =
    '\tdefault:\n' +
    '\t\treturn ("%s");\n' +
    '\t}\n' +
    '}\n';

function
usage()
{
	console.log(process.argv[0] + ' ' + process.argv[1] +
	    ' {-c|-h} [-o <output>] <input>\n');
	process.exit(1);
}

function
parse_arguments(argv)
{
	var opt_c = 0;
	var opt_h = 0;
	var option;
	var obj = {};
	var parser = new mod_getopt.BasicParser('cho:', argv);
	var defs;

	while ((option = parser.getopt()) !== undefined && !option.error) {
		switch (option.option) {
		case 'c':
			opt_c++;
			obj.action = 'c';
			break;
		case 'h':
			opt_h++;
			obj.action = 'h';
			break;
		case 'o':
			obj.output = option.optarg;
			break;
		default:
			usage();
			break;
		}
	}

	obj.input = argv[parser.optind()];

	if (opt_c + opt_h != 1)
		usage();

	if (!obj.input)
		usage();

	defs = fs.readFileSync(obj.input);
	obj.defs = JSON.parse(defs);

	return (obj);
}

function
write(output, str)
{
	if (!output)
		process.stdout.write(str);
	else
		fs.writeFileSync(output, str)
}

function
write_c(defs, output)
{
	var out = '';

	out += prologue;
	out += include;

	out += util.format(func_prologue, 'strerror');
	defs.forEach(function _append_str(e) {
		out += util.format(generic_case, e.code, e.msg);
	});
	out += util.format(func_epilogue, 'unknown v8+ error code');
	out += '\n';

	out += util.format(func_prologue, 'errname');
	defs.forEach(function _append_name(e) {
		out += util.format(errname_case, e.code, e.code);
	});
	out += util.format(func_epilogue, 'unknown v8+ error code');
	out += '\n';

	out += util.format(func_prologue, 'excptype');
	defs.forEach(function _append_excp(e) {
		out += util.format(generic_case, e.code, e.exception);
	});
	out += util.format(func_epilogue, 'Error');

	write(output, out);
}

function
write_header(defs, output)
{
	var out = '';

	out += prologue;
	out += guard_prologue;
	out += util.format(decl_prologue, defs[0].code);
	defs.forEach(function _spew_decl(e, i) {
		if (i > 0)
			out += util.format(decl_one, e.code);
	});
	out += decl_epilogue;
	out += guard_epilogue;

	write(output, out);
}

var action = parse_arguments(process.argv);

switch (action.action) {
case 'c':
	write_c(action.defs, action.output);
	break;
case 'h':
	write_header(action.defs, action.output);
	break;
default:
	usage();
	break;
}
