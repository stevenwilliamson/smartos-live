/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at http://smartos.org/CDDL
 *
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file.
 *
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright (c) 2014, Joyent, Inc. All rights reserved.
 *
 */

// Ensure we're using the platform's node
// XXX TODO update this when it's been moved.
// require('/usr/node/node_modules/platform_node_version').assert();

var assert = require('assert');
var cp = require('child_process');
var props = require('/usr/vm/node_modules/props');
var spawn = cp.spawn;
var utils = require('utils');

// utils
var isUUID = utils.isUUID;
var rtrim = utils.rtrim;

var ZONEINFO_FIELDS = props.ZONEINFO_FIELDS;
var ZONEINFO_PROPERTIES = props.ZONEINFO_PROPERTIES;


/*
 * getZoneinfo() takes a uuid|zonename|null as the first option and
 * attempts to gather information from mdb -k for zones on the system using:
 *
 *   ::walk zone | ::printf "<format>\n" zone_t zone_name ...
 *
 * where the <format> and ... (fields of zone_t) are defined from proptable.js.
 *
 * The passed in callback function will be called with:
 *
 *   callback(err, results)
 *
 * with err being set (will be an Error object) only on error and results being
 * an object keyed by uuid of the data found for the system's zones.
 *
 * NOTE: as this data comes from the kernel, it is only available for running
 * zones.
 *
 */
function getZoneinfo(uuid, options, callback)
{
    var args = ['-k'];
    var buffer = '';
    var cmd = '/usr/bin/mdb';
    var format = '%s';
    var line_count = 0;
    var lines;
    var log;
    var results = {};
    var mdb;
    var mdb_pid;
    var mdb_stderr = '';

    assert(options.log, 'no logger passed to getZoneinfo()');
    log = options.log;

    function _processMdbData(data) {
        var field_idx;
        var fields;
        var line;
        var obj;

        buffer += data.toString();
        lines = buffer.split('\n');
        while (lines.length > 1) {
            line = lines.shift();
            line_count++;
            fields = rtrim(line).split(' ');
            if (fields.length ===
                (1 + Object.keys(ZONEINFO_PROPERTIES).length)) {

                obj = {
                    'zonename': fields[0]
                };

                if (uuid && (obj.zonename != uuid)) {
                    continue;
                }

                field_idx = 1;
                Object.keys(ZONEINFO_PROPERTIES).forEach(function (k) {
                    var field = ZONEINFO_PROPERTIES[k].field;
                    var value = fields[field_idx++];

                    if (ZONEINFO_PROPERTIES[k].loadValueTranslator) {
                        value
                            = ZONEINFO_PROPERTIES[k].loadValueTranslator(value);
                    }

                    obj[field] = value;
                });

                log.trace({object: obj}, 'loaded zoneinfo object');

                if (obj.zonename && obj.zonename.length === 36
                    && isUUID(obj.zonename)) {

                    results[obj.zonename] = obj;
                } else if (obj.zonename !== 'global') {
                    log.error({object: obj},
                        'zoneinfo object is missing zonename');
                }
            } else if (line.replace(/ /g, '').length > 0) {
                log.debug('getZoneinfo(' + uuid + ') ignoring: ' + line);
            }
        }
        buffer = lines.pop();
    }

    function _finishMdb(code) {
        var errmsg;
        var new_err;

        if (code === 0) {
            callback(null, results);
        } else {
            errmsg = rtrim(mdb_stderr);
            new_err = new Error(errmsg);
            log.error({err: new_err, stderr: mdb_stderr},
                'getZoneinfo() mdb[' + mdb.pid + '] "'
                + args.join(',') + '" failed');
            callback(new_err);
            return;
        }
    }

    // Shortcut case for tests, allows us to mock out actual call to zoneadm
    if (options.mdb_stdout) {
        log.trace('mdb_stdout passed in as option, not spawning mdb');

        _processMdbData(options.mdb_stdout);
        mdb = {pid: 'debug'};
        if (options.mdb_stderr) {
            mdb_stderr = options.mdb_stderr;
        }
        _finishMdb(options.mdb_code ? options.mdb_code : 0);

        return; // don't actually spawn
    }

    log.debug({cmdline: cmd + ' ' + args.join(' ')}, 'executing mdb');
    mdb = spawn(cmd, args, {stdio: 'pipe'});
    log.debug('mdb[' + mdb.pid + '] running');
    mdb_pid = mdb.pid;

    mdb.on('close', function (code) {
        log.debug('mdb[' + mdb_pid + '] exited with code: ' + code
            + ' (' + line_count + ' lines to stdout)');
        _finishMdb(code);
    });

    Object.keys(ZONEINFO_PROPERTIES).forEach(function (k) {
        var fmt = ZONEINFO_PROPERTIES[k].format;

        assert(fmt.length > 0, 'invalid format string for ' + k);

        if (ZONEINFO_PROPERTIES[k]) {
            format = format + ' ' + fmt;
        }
    });

    // write the mdb cmd and close stdin now.
    mdb.stdin.end('::walk zone | ::printf "' + format + '\\n" zone_t zone_name '
        + Object.keys(ZONEINFO_PROPERTIES).join(' ') + '\n');

    mdb.stderr.on('data', function (data) {
        mdb_stderr += data.toString();
    });

    mdb.stdout.on('data', function (data) {
        _processMdbData(data.toString());
    });
}

module.exports = {
    getZoneinfo: getZoneinfo
};
